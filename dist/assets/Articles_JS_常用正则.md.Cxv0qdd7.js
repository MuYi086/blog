import{_ as t,o as e,c as a,a7 as c}from"./chunks/framework.CgLK9O2D.js";const f=JSON.parse('{"title":"常用正则","description":"","frontmatter":{"tags":["JS"]},"headers":[],"relativePath":"Articles/JS/常用正则.md","filePath":"Articles/JS/常用正则.md","lastUpdated":1719417334000}'),o={name:"Articles/JS/常用正则.md"},d=c('<h1 id="常用正则" tabindex="-1">常用正则 <a class="header-anchor" href="#常用正则" aria-label="Permalink to &quot;常用正则&quot;">​</a></h1><h2 id="元字符" tabindex="-1">元字符 <a class="header-anchor" href="#元字符" aria-label="Permalink to &quot;元字符&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">元字符</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">.</td><td style="text-align:center;">句号匹配任意单个字符除了换行符。</td></tr><tr><td style="text-align:center;">[ ]</td><td style="text-align:center;">字符种类, 匹配方括号内的任意字符</td></tr><tr><td style="text-align:center;">[^ ]</td><td style="text-align:center;">否定的字符种类, 匹配除了方括号里的任意字符</td></tr><tr><td style="text-align:center;">*</td><td style="text-align:center;">匹配 <code>&gt;=0</code> 个重复的在 <code>*</code> 号之前的字符</td></tr><tr><td style="text-align:center;">+</td><td style="text-align:center;">匹配 <code>&gt;=1</code> 个重复的 <code>+</code> 号之前的字符</td></tr><tr><td style="text-align:center;">?</td><td style="text-align:center;">标记 <code>?</code> 之前的字符为可选</td></tr><tr><td style="text-align:center;">{n, m}</td><td style="text-align:center;">匹配 <code>num</code> 个大括号之间的字符 <code>(n&lt;= num &lt;= m)</code></td></tr><tr><td style="text-align:center;">(xyz)</td><td style="text-align:center;">字符集,匹配与 <code>xyz</code> 完全相等的字符串.</td></tr><tr><td style="text-align:center;">|</td><td style="text-align:center;">或运算符, 匹配符号前或后的字符.</td></tr><tr><td style="text-align:center;">\\</td><td style="text-align:center;">转义字符, 用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\</td></tr><tr><td style="text-align:center;">^</td><td style="text-align:center;">从开始行开始匹配</td></tr><tr><td style="text-align:center;">$</td><td style="text-align:center;">从末端开始匹配</td></tr></tbody></table><p><a href="https://regex101.com/r/xc9GkU/1" target="_blank" rel="noreferrer">在线练习</a></p><h2 id="点运算符" tabindex="-1">点运算符 <code>.</code> <a class="header-anchor" href="#点运算符" aria-label="Permalink to &quot;点运算符 `.`&quot;">​</a></h2><p><code>.</code> 是元字符中最简单的例子。 <code>.</code> 匹配任意单个字符，但不匹配换行符。例如，表达式 <code>.ar</code> 匹配一个任意字符后面跟着是 <code>a</code> 和 <code>r</code>的字符串</p><div class="info custom-block"><p class="custom-block-title">.ar</p><p>&quot;.ar&quot; =&gt; The <a href="#">car</a> <a href="#">par</a>ked in the <a href="#">gar</a>age.</p></div><h2 id="字符集" tabindex="-1">字符集 <a class="header-anchor" href="#字符集" aria-label="Permalink to &quot;字符集&quot;">​</a></h2><p>字符串也叫做字符类.方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。在方括号中的字符集下关心顺序。例如，表达式 <code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code></p><div class="info custom-block"><p class="custom-block-title">[Tt]he</p><p>&quot;[Tt]he&quot; =&gt; <a href="#">The</a> car parked in <a href="#">the</a> garage.</p></div><p>方括号的句号就表示句号。表达式 <code>ar[.]</code> 匹配 <code>ar.</code> 字符串</p><div class="info custom-block"><p class="custom-block-title">ar[.]</p><p>&quot;ar[.]&quot; =&gt; A garage is a good place to park a c<a href="#">ar.</a></p></div><h2 id="否定字符集" tabindex="-1">否定字符集 <a class="header-anchor" href="#否定字符集" aria-label="Permalink to &quot;否定字符集&quot;">​</a></h2><p>一般来说 <code>^</code> 表示一个字符串的开头, 但它用在一个方括号的开头的时候,它表示这个字符集是否定的.例如,表达式 <code>[^c]ar</code> 匹配一个后面跟着 <code>ar</code> 的除了 <code>c</code> 的任意字符.</p><div class="info custom-block"><p class="custom-block-title">[^c]ar</p><p>&quot;[^c]ar&quot; =&gt; The car <a href="#">par</a>ked in the <a href="#">gar</a>age.</p></div><h2 id="重复次数" tabindex="-1">重复次数 <a class="header-anchor" href="#重复次数" aria-label="Permalink to &quot;重复次数&quot;">​</a></h2><ol><li><p><code>*</code> 号匹配在 <code>*</code> 之前的字符出现 <code>大于等于0</code> 次。 例如， 表达式 <code>a*</code> 匹配0或更多个以 <code>a</code> 开头的字符.表达式 <code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串</p><div class="info custom-block"><p class="custom-block-title">[a-z]*</p><p>&quot;[a-z]*&quot; =&gt; T<a href="#">he car parked in the garage</a>.</p></div><p><code>*</code> 字符和 <code>.</code> 字符搭配可以匹配所有的字符 <code>.*</code> <code>*</code>和表示匹配空格的符号 <code>\\s</code> 连起来用, 如表达式 <code>\\s*cat\\s*</code> 匹配0或更多个空格开头和0或更多个空格结尾的 <code>cat</code> 字符串</p><div class="info custom-block"><p class="custom-block-title">\\s<em>cat\\s</em></p><p>&quot;\\s<em>cat\\s</em>&quot; =&gt; The fat <a href="#">cat</a> sat on the con<a href="#">cat</a>enation.</p></div></li><li><p><code>+</code> 号匹配 <code>+</code> 号之前的字符出现 <code>&gt;=1</code> 次. 例如表达式 <code>c.+t</code> 匹配以首字母 <code>c</code> 开头以 <code>t</code> 结尾, 中间跟着至少一个字符的字符串</p><div class="info custom-block"><p class="custom-block-title">c.+t</p><p>&quot;c.+t&quot; =&gt; The fat <a href="#">cat sat on the mat</a>.</p></div></li><li><p><code>?</code>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符可选, 即出现0 或1 次. 例如, 表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>.</p><div class="info custom-block"><p class="custom-block-title">[T]he</p><p>&quot;[T]he&quot; =&gt; <a href="#">The</a> car is parked in the garage.</p><p>&quot;[T]?he&quot; =&gt; <a href="#">The</a> car is parked in t<a href="#">he</a> garage.</p></div></li></ol><h2 id="号" tabindex="-1"><code>{}</code> 号 <a class="header-anchor" href="#号" aria-label="Permalink to &quot;`{}` 号&quot;">​</a></h2><p>在正则表达式中 <code>{}</code> 是一个量词, 常用来一个或一组字符可以重复出现的额次数.例如, 表达式 <code>[0-9]{2, 3}</code> 匹配最少2位最多3位 <code>0~9</code> 的数字</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>&quot;[0-9]{2, 3}&quot; =&gt; The number was 9.<a href="#">999</a> 7 but we rounded it off to <a href="#">10</a>.0.</p></div><p>如果逗号也省略掉则表示重复固定的次数.例如, <code>[0-9]{3}</code> 匹配3位数字</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>&quot;[0-9]{3}&quot; =&gt; The number was 9.<a href="#">999</a>7 but we rounded it off to 10.0</p></div><h2 id="特征标群" tabindex="-1"><code>(...)</code> 特征标群 <a class="header-anchor" href="#特征标群" aria-label="Permalink to &quot;`(...)` 特征标群&quot;">​</a></h2><p>特征标群是一组写在 <code>(...)</code> 中的子模式.例如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数. 但是如果在 <code>{}</code> 前加入特征标群则表示整个标群内的字符重复N次.例如, 表达式 <code>(ab)*</code> 匹配连续出现0或更多个 <code>ab</code> 我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或.例如, <code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><div class="info custom-block"><p class="custom-block-title">(c|g|p)ar</p><p>&quot;(c|g|p)ar&quot; =&gt; The <a href="#">car</a> is <a href="#">par</a>ked in the <a href="#">gar</a>age.</p></div><h2 id="运算符" tabindex="-1"><code>|</code> 运算符 <a class="header-anchor" href="#运算符" aria-label="Permalink to &quot;`|` 运算符&quot;">​</a></h2><p>或运算符就表示或， 用做判断条件 例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code></p><div class="info custom-block"><p class="custom-block-title">(T|t)he|car</p><p>&quot;(T|t)he|car&quot; =&gt; <a href="#">The car </a> is parked in <a href="#">the</a> garage.</p></div><h2 id="转码特殊字符" tabindex="-1">转码特殊字符 <a class="header-anchor" href="#转码特殊字符" aria-label="Permalink to &quot;转码特殊字符&quot;">​</a></h2><p>反斜线 <code>\\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \\ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其签名加上反斜线 <code>\\</code> 例如 <code>.</code> 是用来匹配除换行符外的所有字符的.如果想要匹配句子中的 <code>.</code> 则要写成 <code>\\.</code> 以下这个例子 <code>\\.?</code> 是选择性匹配 <code>.</code></p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>&quot;(f|c|m)at.?&quot; =&gt; The <a href="#">fat cat</a> sat on the <a href="#">mat.</a></p></div><h2 id="锚点" tabindex="-1">锚点 <a class="header-anchor" href="#锚点" aria-label="Permalink to &quot;锚点&quot;">​</a></h2><ol><li><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头 例如, 在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code> . 但如果使用 <code>^b</code> 将匹配不到任何结果. 因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头 例如, <code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串</p><div class="info custom-block"><p class="custom-block-title">(T|t)he</p><p>&quot;(T|t)he&quot; =&gt; <a href="#">The</a> car is parked in <a href="#">the</a> garage. &quot;^(T|t)he&quot; =&gt; <a href="#">The</a> car is parked in the garage.</p></div></li><li><p><code>$</code> 号用来匹配字符是否最后一个 例如, <code>(at\\.)$</code> 匹配以 <code>at.</code> 结尾的字符串</p><div class="info custom-block"><p class="custom-block-title">(at.)</p><p>&quot;(at.)&quot; =&gt; The fat c<a href="#">at.</a> s<a href="#">at.</a> on the m<a href="#">at.</a> &quot;(at.)$&quot; =&gt; The fat cat. sat. on the m<a href="#">at.</a></p></div></li></ol><h2 id="简写字符集" tabindex="-1">简写字符集 <a class="header-anchor" href="#简写字符集" aria-label="Permalink to &quot;简写字符集&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;">简写</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">.</td><td style="text-align:center;">除换行符外的所有字符</td></tr><tr><td style="text-align:center;">\\w</td><td style="text-align:center;">匹配所有字母数字, 等同于<code>[a-zA-Z0-9_]</code></td></tr><tr><td style="text-align:center;">\\W</td><td style="text-align:center;">匹配所有非字母数字, 即符号, 等同于 <code>[^\\w]</code></td></tr><tr><td style="text-align:center;">\\d</td><td style="text-align:center;">匹配数字 <code>[0-9]</code></td></tr><tr><td style="text-align:center;">\\D</td><td style="text-align:center;">匹配非数字 <code>[^\\d]</code></td></tr><tr><td style="text-align:center;">\\s</td><td style="text-align:center;">匹配所有空格字符, 等同于 <code>[\\t\\n\\f\\r\\p{Z}]</code></td></tr><tr><td style="text-align:center;">\\S</td><td style="text-align:center;">匹配所有非空格字符 <code>[^\\s]</code></td></tr><tr><td style="text-align:center;">\\f</td><td style="text-align:center;">匹配一个换页符</td></tr><tr><td style="text-align:center;">\\n</td><td style="text-align:center;">匹配一个换行符</td></tr><tr><td style="text-align:center;">\\r</td><td style="text-align:center;">匹配一个回车符</td></tr><tr><td style="text-align:center;">\\t</td><td style="text-align:center;">匹配一个制表符</td></tr><tr><td style="text-align:center;">\\v</td><td style="text-align:center;">匹配一个垂直制表符</td></tr><tr><td style="text-align:center;">\\p</td><td style="text-align:center;">匹配CR/LF(等同于 <code>\\r\\n</code> ), 用来匹配 <code>DOS</code> 行终止符</td></tr></tbody></table><h2 id="零宽度断言" tabindex="-1">零宽度断言 <a class="header-anchor" href="#零宽度断言" aria-label="Permalink to &quot;零宽度断言&quot;">​</a></h2><ol><li><p>正先行断言</p><p><code>?=...</code> 表示第一部分表达式之后必须跟着 <code>?=...</code> 定义的表达式 返回结果只包含满足匹配条件的第一部分表达式.定义一个正先行断言要使用 <code>()</code> 在括号内部使用一个问号和等号: <code>(?=...)</code> 正先行断言的内容写在括号中的等号后面。例如,表达式 <code>(T|t)he(?=\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code> , 在括号中我们又定义了正先行断言 <code>(?=\\sfat)</code> ， 即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code></p><div class="info custom-block"><p class="custom-block-title">(T|t)he(?=\\sfat)</p><p>&quot;(T|t)he(?=\\sfat)&quot; =&gt; <a href="#">The</a> fat cat sat on the mat.</p></div></li><li><p>负先行断言</p><p><code>?!</code> 用于筛选所有匹配结果, 筛选条件为其后不跟随断言中的格式. <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样, 区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code> 表达式 <code>(T|t)he(?!\\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>, 且其后不跟着 <code>(空格)fat</code></p><div class="info custom-block"><p class="custom-block-title">(T|t)he(?!\\sfat)</p><p>&quot;(T|t)he(?!\\sfat)&quot; =&gt; The fat cat sat on <a href="#">the</a> mat.</p></div></li><li><p>正后发断言</p><p><code>(?&lt;=...)</code> 用于筛选所有匹配结果, 筛选条件为其前跟随者断言中定义的格式. 例如, 表达式 <code>(?&lt;=(T|t)he\\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code> , 且其前跟着 <code>The</code> 或 <code>the</code></p><div class="info custom-block"><p class="custom-block-title">(?&lt;=(T|t)he\\s)(fat|mat)</p><p>&quot;(?&lt;(T|t)he\\s)(fat|mat)&quot; =&gt; The <a href="#">fat</a> cat sat on the <a href="#">mat.</a></p></div></li><li><p>负后发断言</p><p><code>(?&lt;!...)</code> 用于筛选所有匹配结果, 筛选条件为其前不跟随断言中定义的格式.例如, 表达式 <code>(?&lt;!(T|t)he\\s)(cat)</code> 匹配 <code>cat</code>, 且其前不跟着 <code>The</code> 或 <code>the</code></p><div class="info custom-block"><p class="custom-block-title">(?&lt;!(T|t)he\\s)(cat)</p><p>&quot;(?&lt;!(T|t)he\\s)(cat)&quot; =&gt; The cat sat on <a href="#">cat</a>.</p></div></li></ol><h2 id="标志" tabindex="-1">标志 <a class="header-anchor" href="#标志" aria-label="Permalink to &quot;标志&quot;">​</a></h2><p>标志也叫模式修正符,因为它可以用来修改表达式的搜索结果.这些标志可以任意的组合使用,它也是整个正则表达式的一部分.</p><table tabindex="0"><thead><tr><th style="text-align:center;">标志</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td style="text-align:center;">i</td><td style="text-align:center;">忽略大小写</td></tr><tr><td style="text-align:center;">g</td><td style="text-align:center;">全局搜索</td></tr><tr><td style="text-align:center;">m</td><td style="text-align:center;">多行修饰符, 锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始</td></tr></tbody></table><ol><li><p>忽略大小写</p><p>修饰语 <code>i</code> 用于忽略大小写. 例如, 表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>, 在后面的 <code>i</code> 将其条件修改为忽略大小写, 则变成搜索 <code>the</code> 和 <code>The</code>, <code>g</code> 表示全局搜索</p><div class="info custom-block"><p class="custom-block-title">The</p><p>&quot;The&quot; =&gt; <a href="#">The</a> fat cat sat on the mat.</p><p>&quot;/The/gi&quot; =&gt; <a href="#">The</a> fat cat sat on <a href="#">the</a> mat.</p></div></li><li><p>全局搜索</p><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配, 即（不仅仅返回第一个匹配的, 而是返回全部). 例如, 表达式 <code>/.(at)/g</code> 表示搜索任意字符 (除了换行) + <code>at</code>, 并返回结果</p><div class="info custom-block"><p class="custom-block-title">/.(at)/</p><p>&quot;/.(at)/&quot; =&gt; The <a href="#">fat</a> cat sat on the mat.</p><p>&quot;/.(at)/g&quot; =&gt; The <a href="#">fat cat sat </a>on the <a href="#">mat</a>.</p></div></li><li><p>多行修饰符</p><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配 像之前介绍的 <code>(^,$)</code> 用于检测格式是否是在待检测字符串的开头或结尾.但我们如果想要在每行的开头和结尾生效, 我们需要用到多行修饰符 <code>m</code> 例如, 表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code>, 末尾可选除换行符外任意字符. 根据 <code>m</code> 修饰符, 现在表达式匹配每行的结尾</p><div class="info custom-block"><p class="custom-block-title">/.at(.)?$/</p><p>&quot;/.at(.)?$/&quot; =&gt; The fat cat sat on the <a href="#">mat.</a></p></div><div class="info custom-block"><p class="custom-block-title">/.at(.)?$/gm</p><p>&quot;/.at(.)?$/gm&quot; =&gt; The <a href="#">fat</a> cat <a href="#">sat</a> on the <a href="#">mat.</a></p></div></li></ol><h2 id="贪婪匹配与惰性匹配" tabindex="-1">贪婪匹配与惰性匹配 <a class="header-anchor" href="#贪婪匹配与惰性匹配" aria-label="Permalink to &quot;贪婪匹配与惰性匹配&quot;">​</a></h2><p>正则表达式默认采用贪婪匹配模式, 在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式</p><div class="info custom-block"><p class="custom-block-title">(.*at)/</p><p>&quot;/(.*at)/&quot; =&gt; <a href="#">The fat cat sat on the mat</a>.</p><p>&quot;/(.*?at)/&quot; =&gt; <a href="#">The fat</a> cat sat on the mat.</p></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noreferrer">learn-regex</a></p><div style="display:none;" data-pagefind-meta="base64:JTdCJTIydGFncyUyMiUzQSU1QiUyMkpTJTIyJTVEJTJDJTIyZGF0ZSUyMiUzQTE3MTk0MTczMzQwMDAlN0Q="></div>',47),l=[d];function r(s,i,n,h,p,u){return e(),a("div",null,l)}const m=t(o,[["render",r]]);export{f as __pageData,m as default};
